

<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>render.js - Alpinejs-app Documentation</title>
    
    <meta name="description" content="A Simplest Single Page Application (SPA) library for Alpine.js." />
    
    
    

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>

    
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h3>Tutorials</h3><ul><li><a href="tutorial-start.html">Getting Started</a><ul class='members'><li data-type='method' style='display: none;'><a href="tutorial-start.html#installation">Installation</a></li><li data-type='method' style='display: none;'><a href="tutorial-start.html#first-app">First app</a></li></ul></li><li><a href="tutorial-components.html">Components</a><ul class='members'><li data-type='method' style='display: none;'><a href="tutorial-components.html#component-lifecycle-and-event-handling">Component Lifecycle and Event Handling</a></li><li data-type='method' style='display: none;'><a href="tutorial-components.html#event-emitter">Event emitter</a></li><li data-type='method' style='display: none;'><a href="tutorial-components.html#custom-elements">Custom Elements</a></li><li data-type='method' style='display: none;'><a href="tutorial-components.html#examples">Examples</a></li></ul></li><li><a href="tutorial-directives.html">Directives</a><ul class='members'><li data-type='method' style='display: none;'><a href="tutorial-directives.html#directive-x-template">Directive: **x-template**</a></li><li data-type='method' style='display: none;'><a href="tutorial-directives.html#directive-x-render">Directive: **x-render**</a></li><li data-type='method' style='display: none;'><a href="tutorial-directives.html#directive-x-scope-level">Directive: **x-scope-level**</a></li></ul></li><li><a href="tutorial-magics.html">Magics</a><ul class='members'><li data-type='method' style='display: none;'><a href="tutorial-magics.html#magic-app">Magic: **$app**</a></li><li data-type='method' style='display: none;'><a href="tutorial-magics.html#magic-component">Magic: **$component**</a></li><li data-type='method' style='display: none;'><a href="tutorial-magics.html#magic-parent">Magic: **$parent**</a></li><li data-type='method' style='display: none;'><a href="tutorial-magics.html#magic-params">Magic: **$params**</a></li></ul></li></ul><h3>Classes</h3><ul><li><a href="AlpineComponent.html">AlpineComponent</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AlpineComponent.html#destroy">destroy</a></li><li data-type='method' style='display: none;'><a href="AlpineComponent.html#init">init</a></li></ul></li><li><a href="Component.html">Component</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Component.html#destroy">destroy</a></li><li data-type='method' style='display: none;'><a href="Component.html#init">init</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="app.html">app</a><ul class='methods'><li data-type='method' style='display: none;'><a href="app.html#.$">$</a></li><li data-type='method' style='display: none;'><a href="app.html#.$all">$all</a></li><li data-type='method' style='display: none;'><a href="app.html#.$append">$append</a></li><li data-type='method' style='display: none;'><a href="app.html#.$attr">$attr</a></li><li data-type='method' style='display: none;'><a href="app.html#.$data">$data</a></li><li data-type='method' style='display: none;'><a href="app.html#.$elem">$elem</a></li><li data-type='method' style='display: none;'><a href="app.html#.$empty">$empty</a></li><li data-type='method' style='display: none;'><a href="app.html#.$event">$event</a></li><li data-type='method' style='display: none;'><a href="app.html#.$off">$off</a></li><li data-type='method' style='display: none;'><a href="app.html#.$on">$on</a></li><li data-type='method' style='display: none;'><a href="app.html#.$param">$param</a></li><li data-type='method' style='display: none;'><a href="app.html#.$parse">$parse</a></li><li data-type='method' style='display: none;'><a href="app.html#.$ready">$ready</a></li><li data-type='method' style='display: none;'><a href="app.html#.afetch">afetch</a></li><li data-type='method' style='display: none;'><a href="app.html#.call">call</a></li><li data-type='method' style='display: none;'><a href="app.html#.emit">emit</a></li><li data-type='method' style='display: none;'><a href="app.html#.fetch">fetch</a></li><li data-type='method' style='display: none;'><a href="app.html#.isE">isE</a></li><li data-type='method' style='display: none;'><a href="app.html#.isF">isF</a></li><li data-type='method' style='display: none;'><a href="app.html#.isN">isN</a></li><li data-type='method' style='display: none;'><a href="app.html#.isO">isO</a></li><li data-type='method' style='display: none;'><a href="app.html#.isS">isS</a></li><li data-type='method' style='display: none;'><a href="app.html#.log">log</a></li><li data-type='method' style='display: none;'><a href="app.html#.noop">noop</a></li><li data-type='method' style='display: none;'><a href="app.html#.off">off</a></li><li data-type='method' style='display: none;'><a href="app.html#.on">on</a></li><li data-type='method' style='display: none;'><a href="app.html#.once">once</a></li><li data-type='method' style='display: none;'><a href="app.html#.only">only</a></li><li data-type='method' style='display: none;'><a href="app.html#.parsePath">parsePath</a></li><li data-type='method' style='display: none;'><a href="app.html#.plugin">plugin</a></li><li data-type='method' style='display: none;'><a href="app.html#.render">render</a></li><li data-type='method' style='display: none;'><a href="app.html#.resolve">resolve</a></li><li data-type='method' style='display: none;'><a href="app.html#.restorePath">restorePath</a></li><li data-type='method' style='display: none;'><a href="app.html#.savePath">savePath</a></li><li data-type='method' style='display: none;'><a href="app.html#.start">start</a></li><li data-type='method' style='display: none;'><a href="app.html#.toCamel">toCamel</a></li><li data-type='method' style='display: none;'><a href="app.html#.trace">trace</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">render.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { app, isElement, isFunction, isString } from "./app"

var _plugins = {}
var _default_plugin;

/**
 *   Register a render plugin, at least 2 functions must be defined in the options object:
 * @param {string} name
 * @param {object} options
 * @param {function} render - (element, options) to show a component, called by {@link app.render}
 * @param {function} cleanup - (element) - optional, run additional cleanups before destroying a component
 * @param {function} data - (element) - return the component class instance for the given element or the main
 * @param {boolean} [options.default] - if not empty make this plugin default
 * @param {class} [options.Component] - optional base component constructor, it will be registered as app.{Type}Component, like AlpineComponent, KoComponent,... to easy create custom components
 *
 * The reason for plugins is that while this is designed for Alpine.js, the idea originated by using Knockout.js with this system,
 * the plugin can be found at [app.ko.js](https://github.com/vseryakov/backendjs/blob/c97ca152dfd55a3841d07b54701e9d2b8620c516/web/js/app.ko.js).
 *
 * There is a simple plugin in examples/simple.js to show how to use it without any rendering engine with vanillla HTML, not very useful though.
 */
app.plugin = (name, options) => {
    if (!name || !isString(name)) throw Error("type must be defined")
    if (options) {
        for (const p of ["render", "cleanup", "data"]) {
            if (options[p] &amp;&amp; !isFunction(options[p])) throw Error(p + " must be a function");
        }
        if (isFunction(options?.Component)) {
            app[`${name.substr(0, 1).toUpperCase() + name.substr(1).toLowerCase()}Component`] = options.Component;
        }
    }
    var plugin = _plugins[name] = _plugins[name] || {};
    if (options?.default) _default_plugin = plugin;
    return Object.assign(plugin, options);
}

/**
 * Return component data instance for the given element or the main component if omitted. This is for
 * debugging purposes or cases when calling some known method is required.
 * @param {string|HTMLElement} element
 * @param {number} [level] - if is not a number then the closest scope is returned otherwise only the requested scope at the level or undefined.
 * This is useful for components to make sure they use only the parent's scope for example.
 *
 * @returns {Proxy|undefined} to get the actual object pass it to **Alpine.raw(app.$data())**
 */
app.$data = (element, level) => {
    if (isString(element)) element = app.$(element);
    for (const p in _plugins) {
        if (!_plugins[p].data) continue;
        const d = _plugins[p].data(element, level);
        if (d) return d;
    }
}

/**
 * Returns an object with **template** and **component** properties.
 *
 * Calls {@link app.parsePath} first to resolve component name and params.
 *
 * Passing an object with 'template' set will reuse it, for case when template is already resolved.
 *
 * The template property is set as:
 *  - try app.templates[.name]
 *  - try an element with ID name and use innerHTML
 *  - if not found and dflt is given try the same with it
 *  - if template texts starts with # it means it is a reference to another element's innerHTML,
 *     otemplate is set with the original template before replacing the template property
 *  - if template text starts with $ it means it is a reference to another template in **app.templates**,
 *     otemplate is set with the original template before replacing the template property
 *
 * The component property is set as:
 *  - try app.components[.name]
 *  - try app.components[dflt]
 *  - if resolved to a function return
 *  - if resolved to a string it refers to another component, try app.templates[component],
 *     ocomponent is set with the original component string before replacing the component property
 *
 * if the component property is empty then this component is HTML template.
 * @param {string} path
 * @param {string} [dflt]
 * @returns {object} in format { name, params, template, component }
 */
app.resolve = (path, dflt) => {
    const tmpl = app.parsePath(path);
    app.trace("resolve:", path, dflt, tmpl);
    var name = tmpl?.name, templates = app.templates, components = app.components;
    var template = tmpl.template || templates[name] || document.getElementById(name);
    if (!template &amp;&amp; dflt) {
        template = templates[dflt] || document.getElementById(dflt);
        if (template) tmpl.name = dflt;
    }
    if (isString(template) &amp;&amp; template.startsWith("#")) {
        template = document.getElementById(tmpl.otemplate = template.substr(1));
    } else
    if (isString(template) &amp;&amp; template.startsWith("$")) {
        template = templates[tmpl.otemplate = template.substr(1)];
    }

    if (!template) return;
    tmpl.template = template;
    var component = components[name] || components[tmpl.name];
    if (isString(component)) {
        component = components[tmpl.ocomponent = component];
    }
    tmpl.component = component;
    return tmpl;
}

/**
 * Show a component, options can be a string to be parsed by {@link app.parsePath} or an object with { name, params } properties.
 * if no **params.$target** provided a component will be shown inside the main element defined by {@link app.$target}.
 *
 * It returns the resolved component as described in {@link app.resolve} method after rendering or nothing if nothing was shown.
 *
 * When showing main app the current component is asked to be deleted first by sending an event __prepare:delete__,
 * a component that is not ready to be deleted yet must set the property __event.stop__ in the event
 * handler __onPrepareDelete(event)__ in order to prevent rendering new component.
 *
 * To explicitly disable history pass __options.$nohistory__ or __params.$nohistory__ otherwise main components are saved automatically by sending
 * the __path:save__ event.
 *
 * A component can globally disable history by creating a static property __$nohistory__ in the class definition.
 *
 * To disable history all together set `app.$nohistory = true`.
 *
 * @param {string|object} options
 * @param {string} [dflt]
 * @returns {object|undefined}
 */
app.render = (options, dflt) => {
    var tmpl = app.resolve(options, dflt);
    if (!tmpl) return;

    var params = tmpl.params = Object.assign(tmpl.params || {}, options?.params);
    params.$target = options.$target || params.$target || app.$target;

    app.trace("render:", options, tmpl.name, tmpl.params);

    const element = isElement(params.$target) || app.$(params.$target);
    if (!element) return;

    var plugin = tmpl.component?.$type || options?.plugin || params.$plugin;
    plugin = _plugins[plugin] || _default_plugin;
    if (!plugin?.render) return;

    // Replacing main component
    if (params.$target == app.$target) {
        // Ask if it can be destroyed first
        var ev = { name: tmpl.name, params };
        app.emit(app.event, "prepare:delete", ev);
        if (ev.stop) return;

        // Cleanup by all plugins
        var plugins = Object.values(_plugins);
        for (const p of plugins.filter(x => x.cleanup)) {
            app.call(p.cleanup, element);
        }

        // Save in history if not explicitly asked not to
        if (!(options?.$nohistory || params.$nohistory || tmpl.component?.$nohistory || app.$nohistory)) {
            queueMicrotask(() => {
                app.emit("path:save", tmpl);
            });
        }
    }
    app.emit("component:render", tmpl);
    plugin.render(element, tmpl);
    return tmpl;
}

app.on("alpine:init", () => {
    for (const p in _plugins) {
        app.call(_plugins[p], "init");
    }
});

</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> using the <a href="https://github.com/vseryakov/docdash">docdash</a> theme.
</footer>


<script src="scripts/search.js" defer></script>



<script src="scripts/collapse.js" defer></script>



</body>
</html>
